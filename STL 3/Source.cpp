#include<iostream>
#include<memory>
#include<string>
#include<stdio.h>
#include<stdlib.h>
using namespace std;

/*
 
	STL- стандартная библиотека шаблонов
	
	Состоит из

	Контейнер-управляет и размещает данные(объект для хранения и работы с даннами)
	Алгоритмы-функции для работы с данными в контейнере
	Итераторы-указатель для перемещения по данным конкретного контейнера
	Функторы-Механизм для инкупсуляции(public,private и т.д)

	Алокатор-Распределитель памяти
	Предикат-унарный(++ и --),бинарный(0 и 1)- подмножество функторов, в которых тип возвращаемого значения operator() bool
*/

//void func()
//{
//	FILE* F;
//	if (!(F == fopen("test.txt", "rt")))
//	{
//		cout << "\nНе удалось открыть файл!\n";
//		exit(0);
//	}
//	// здесь может возникнуть исключение
//	// и до fclose(F) мы не дойдем
//	fclose(F);
//}

//class FileOpen
//{
//	FILE* F;
//
//public:
//
//	FileOpen(const char* filename,const char* mode)
//	{
//		if (!(F == fopen(filename, mode)))
//		{
//			cout << "\nНе удалось открыть файл!\n";
//			exit(0);
//		}
//	}
//
//	~FileOpen()
//	{
//		fclose(F);
//	}
//
//};

//void func()
//{
//	FileOpen Myfile("test.txt", "r+");
//}

//auto ptr - автоматичесий указатель
/*
	template<class x>
	class std::auto_ptr
	{
		X* ptr;
	public:
		//Конструктор
		explicit(Предетврощает неявное преобразование типов) auto_ptr(X* p=0) throw()
		{
			ptr=p;
		}
		~auto_ptr()throw()
		{
			delete ptr;

		}

		//Оператор разоменования позволяет получить объект
		X& operator*()const throw()
		{
			return 0;
		}

		//Оператор -> позволяет получить указатель
		X* operator->()const throw()
		{
			return 0;
		}

		

	}


	

*/

//class Temp
//{
//public:
//	Temp() 
//	{
//		cout << "\nTemp\n";
//	}
//
//	void Test()
//	{
//		cout << "\nTest\n";
//	}
//
//	~Temp()
//	{
//		cout << "\n~Temp\n";
//	}
//
//};

//class string
/*
	operator[]-доступ к конкретным символам в строке
	c_str()-конвертация строки в const char* 
	append()-добавление в конец строки
	replace-замещение одного или более символов в заданной позиции
	empty - определение есть ли в строке символы
	find - нахождение первого вхождения заданного символа
	rfind- нахождение последнего вхождения заданного символа(поиск идет с конца)
	find_first_of - нахождение первого вхождения символов из заданного набора
	substr-возвращает подстроку
	find_first_not_of- нахождение первого вхождения символа в строке не входящего в заданный набор
	compare-сравнение
*/


//Итераторы
/*
	#include<iterator>

  Входные - служат для чтения адресуемых данных. Поддеживает операции( ==, !=, *i, ++i).
  Выходные - адресуют объекты в которые должны быть записанны данные. Поддерживают операции( *-(только с левой стороны присваивания), ++i, i++, *i=t, *i++=t)
  Однонаправленные - обладают всеми свойствами входных и выходных и могут перемещаться от начал последовательности в конец.Поддерживают все операции итераторов ввода/вывода и кроме того позволяют без ограничения применять присваение
  Двунаправленные - обладают свойствами одноаправленных но смпособны перемещаться в любом направлении по цепочке данных. Имеют доп. операцию(--i,i--)
  Итераторы произвольного доступа- обладают функциональностью всех четырех видов итераторов. Поддерживают операции сравнения и адресной арифметики, то есть непосредвственный непосредственный доступ по индексу i+=n, i+n, i-=n, i1-i2, i[n], i1<i2, i1<=i2, i1>i2, i1>=i2.
  Итераторы вставки
  Итераторы потоков


  advance() и distance()
  
  template<class InIter, class Dist>
	void advance(InInter &itr, Dist d)-увеличивает итератор itr на d
  template<class InIter>
	void distance(InInter &start, InInter &end)

*/

int main()
{
	//Создаем два автоматических указателя
	//Под один из них выделяем тип TEMP
	//auto_ptr<Temp>ptr1(new Temp), ptr2;
	////Передача права владения
	//ptr2 = ptr1;
	////Вызов функции через автоматический указатель
	//ptr2->Test();
	////Присваение атоматического указателя обычному указателю на объект
	//Temp* ptr = ptr2.get();
	////Вызов функции через обычный указатель
	//ptr->Test();



	string s = "Hello world";
	int nWordEnd = s.find(' ');
	string sub_str = s.substr(0, nWordEnd);
	cout << "String: " << s, cout << "\nSub_str: " << sub_str;


	return 0;
}